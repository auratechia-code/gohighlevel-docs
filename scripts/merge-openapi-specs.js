#!/usr/bin/env node

/**
 * Merges all individual GoHighLevel OpenAPI 3.0 specs (from specs/original/apps/)
 * into a single unified OpenAPI spec at specs/merged-openapi.json.
 *
 * Handles:
 * - Merging paths from all 36 spec files
 * - Merging component schemas (with prefixing to avoid collisions)
 * - Resolving $ref to ../common/common-schemas.json
 * - Merging tags, security schemes, and servers
 */

const fs = require("fs");
const path = require("path");

const APPS_DIR = path.join(__dirname, "..", "specs", "original", "apps");
const COMMON_SCHEMAS_PATH = path.join(
  __dirname,
  "..",
  "specs",
  "original",
  "common",
  "common-schemas.json"
);
const OUTPUT_PATH = path.join(__dirname, "..", "specs", "merged-openapi.json");
const SUMMARY_PATH = path.join(__dirname, "..", "generated", "api-summary.json");

function loadJSON(filePath) {
  return JSON.parse(fs.readFileSync(filePath, "utf-8"));
}

function getSpecFiles() {
  return fs
    .readdirSync(APPS_DIR)
    .filter((f) => f.endsWith(".json"))
    .sort();
}

/**
 * Rewrite $ref values that point to ../common/common-schemas.json
 * to point to the local #/components/schemas/ instead.
 */
function rewriteRefs(obj) {
  if (obj === null || typeof obj !== "object") return obj;

  if (Array.isArray(obj)) {
    return obj.map((item) => rewriteRefs(item));
  }

  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (
      key === "$ref" &&
      typeof value === "string" &&
      value.includes("common-schemas.json")
    ) {
      // ../common/common-schemas.json#/components/schemas/BadRequestDTO
      // -> #/components/schemas/BadRequestDTO
      const schemaName = value.split("/").pop();
      result[key] = `#/components/schemas/${schemaName}`;
    } else {
      result[key] = rewriteRefs(value);
    }
  }
  return result;
}

function merge() {
  const specFiles = getSpecFiles();
  console.log(`Found ${specFiles.length} API spec files to merge.\n`);

  // Load common schemas
  let commonSchemas = {};
  if (fs.existsSync(COMMON_SCHEMAS_PATH)) {
    const common = loadJSON(COMMON_SCHEMAS_PATH);
    commonSchemas = common.components?.schemas || {};
    console.log(
      `Loaded ${Object.keys(commonSchemas).length} common schemas.\n`
    );
  }

  const merged = {
    openapi: "3.0.0",
    info: {
      title: "GoHighLevel API v2 - Unified",
      description:
        "Unified OpenAPI specification for the GoHighLevel API v2. Auto-generated by merging all individual API module specs from the official GoHighLevel/highlevel-api-docs repository.",
      version: "2.0.0",
      contact: {
        name: "GoHighLevel Developer Docs",
        url: "https://marketplace.gohighlevel.com/docs/oauth/GettingStarted",
      },
    },
    servers: [
      {
        url: "https://services.leadconnectorhq.com",
        description: "GoHighLevel API v2",
      },
    ],
    paths: {},
    tags: [],
    components: {
      schemas: { ...commonSchemas },
      securitySchemes: {},
    },
    security: [],
  };

  const tagSet = new Set();
  const stats = {
    totalPaths: 0,
    totalOperations: 0,
    totalSchemas: Object.keys(commonSchemas).length,
    perModule: [],
  };

  for (const file of specFiles) {
    const moduleName = file.replace(".json", "");
    const filePath = path.join(APPS_DIR, file);
    const spec = loadJSON(filePath);

    let modulePaths = 0;
    let moduleOps = 0;

    // Merge paths
    const rewrittenPaths = rewriteRefs(spec.paths || {});
    for (const [pathKey, pathValue] of Object.entries(rewrittenPaths)) {
      if (merged.paths[pathKey]) {
        // Path already exists - merge methods
        for (const [method, operation] of Object.entries(pathValue)) {
          if (!merged.paths[pathKey][method]) {
            merged.paths[pathKey][method] = operation;
            moduleOps++;
          } else {
            console.warn(
              `  WARNING: Duplicate ${method.toUpperCase()} ${pathKey} in ${file}, skipping.`
            );
          }
        }
      } else {
        merged.paths[pathKey] = pathValue;
        moduleOps += Object.keys(pathValue).length;
      }
      modulePaths++;
    }

    // Merge tags
    for (const tag of spec.tags || []) {
      if (!tagSet.has(tag.name)) {
        tagSet.add(tag.name);
        merged.tags.push({
          name: tag.name,
          description: tag.description || `${moduleName} API`,
          "x-module": moduleName,
        });
      }
    }

    // Merge component schemas
    const rewrittenSchemas = rewriteRefs(spec.components?.schemas || {});
    for (const [schemaName, schema] of Object.entries(rewrittenSchemas)) {
      if (!merged.components.schemas[schemaName]) {
        merged.components.schemas[schemaName] = schema;
        stats.totalSchemas++;
      }
    }

    // Merge security schemes
    for (const [schemeName, scheme] of Object.entries(
      spec.components?.securitySchemes || {}
    )) {
      if (!merged.components.securitySchemes[schemeName]) {
        merged.components.securitySchemes[schemeName] = scheme;
      }
    }

    stats.totalPaths += modulePaths;
    stats.totalOperations += moduleOps;
    stats.perModule.push({
      module: moduleName,
      paths: modulePaths,
      operations: moduleOps,
      schemas: Object.keys(spec.components?.schemas || {}).length,
    });

    console.log(
      `  ${moduleName}: ${modulePaths} paths, ${moduleOps} operations`
    );
  }

  // Sort tags alphabetically
  merged.tags.sort((a, b) => a.name.localeCompare(b.name));

  // Write merged spec
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_PATH, JSON.stringify(merged, null, 2), "utf-8");

  // Write summary
  fs.mkdirSync(path.dirname(SUMMARY_PATH), { recursive: true });
  fs.writeFileSync(
    SUMMARY_PATH,
    JSON.stringify(
      {
        generatedAt: new Date().toISOString(),
        sourceRepo: "https://github.com/GoHighLevel/highlevel-api-docs",
        baseUrl: "https://services.leadconnectorhq.com",
        stats,
      },
      null,
      2
    ),
    "utf-8"
  );

  console.log(`\n--- Merge Complete ---`);
  console.log(`Total paths:      ${stats.totalPaths}`);
  console.log(`Total operations: ${stats.totalOperations}`);
  console.log(`Total schemas:    ${stats.totalSchemas}`);
  console.log(`Modules:          ${specFiles.length}`);
  console.log(`\nOutput: ${OUTPUT_PATH}`);
  console.log(`Summary: ${SUMMARY_PATH}`);
}

merge();
